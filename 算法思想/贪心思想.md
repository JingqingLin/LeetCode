# 💣435. 无重叠区间
## 贪心思想
### 从起点的贪心算法
先按照**起点**对区间进行排序。利用一个 `prev` 指针追踪刚刚添加到最终列表中的区间。考虑三种情况：  
> 蓝色表示前一个已加入最终列表的区间，绿色为当前区间  
![](https://pic.leetcode-cn.com/311ab170f5b301b3a97ebb5be89317e5c9ca47be5117b5bfbf3083ceec7346b4-image.png)

- Case 1：  
不移除任何区间，将 `prev` 赋值为后面的区间，移除区间数量不变。  
- Case 2:（一开始只是单纯丢弃了后面的区间）  
只保留后一个区间。因为后一个区间的长度更小，可以留下更多的空间（$A$ 和 $B$），容纳更多的区间。因此， `prev` 更新为当前区间，移除区间的数量 +1。

- Case 3:  
这种情况下，我们用**贪心策略**处理问题，保留前一个区间。（因为前一个区间的右端点更小，可以为后面区间腾出更多空间）`prev` 不变，移除区间的数量 +1。

### 从终点的贪心算法
先按照**终点**对区间进行排序。利用一个 `prev` 指针追踪刚刚添加到最终列表中的区间。同样地，也考虑上述三种情况：  
![](https://pic.leetcode-cn.com/373670ac0b63f74c34f7d3beac0db5d78e950d493ca9f7ac2c926313ee4445cb-image.png)  
Case 2, Case 3 都是保留前一个区间。 

## 动态规划
见[官方题解](https://leetcode-cn.com/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode/)