实现 BFS 时需要考虑以下问题：
- 队列：用来存储每一轮遍历得到的节点；
- 标记：对于遍历过的节点，应该将它标记，防止重复遍历。
```
void BFS()
{
    定义队列;
    定义备忘录，用于记录已经访问的位置；

    判断边界条件，是否能直接返回结果的。

    将起始位置加入到队列中，同时更新备忘录。

    while (队列不为空) {
        获取当前队列中的元素个数。
        for (元素个数) {
            取出一个位置节点。
            判断是否到达终点位置。
            获取它对应的下一个所有的节点。
            条件判断，过滤掉不符合条件的位置。
            新位置重新加入队列。
        }
    }

}
```

# 1091. 二进制矩阵中的最短路径
还不会写 BFS 代码，参考了题解  
**测试用例：**  
- [[0]]  
- 起始点即为阻塞路：[[1, 0, 0], [1, 1, 0], [1, 1, 0]]  

**注意点：**  
- 遍历各个方向的先后顺序影响运行速度。一般是先右再左

        int[][] direction = {{1, 0}, {1, 1}, {1, -1}, {0, 1}, {0, -1}, {-1, 0}, {-1, -1}, {-1, 1}};
- ⭐标记位置的选择很重要。某个点插入队列后应立即标为 1，如下代码：  
![](https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting/img/Snipaste_2020-02-11_11-19-18.png)  
否则，搜索到某层时，会把同一层的兄弟节点作为下一层节点。如下图，遍历到第二层，红框内的两个 $0$ 都会把对方作为下一层节点放入队列。   
<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting/img/Snipaste_2020-02-11_11-38-24.png" width = "40%" height = "40%">  
因此，可能会出现这种无意义的路径，导致队列太大，运行时堆内存溢出  
<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting/img/20200211115043.png" width = "40%" height = "40%">  

