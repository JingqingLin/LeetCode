# 215. 数组中的第K个最大元素
## 快速选择
- `Arrays.sort()` 调库快排

时间复杂度 $O(nlogn)$，空间复杂度 $O(1)$  


- `randPartition()` 返回 pivot 的下标 `p`，代表 `pivot` 为 第 `p` 小的值。通过 `p` 与 `k` 比较来反复调用。

时间复杂度 $O(n)$，空间复杂度 $O(1)$

**注：**  
`randPartition()` 把数组分成了两部分。如果是快速排序，会在这里递归地对两部分进行快速排序。而在快速选择中，由于知道要找的第 $N - k$ 小的元素在哪部分中，我们不需要对两部分都做处理，这样就将平均时间复杂度下降到 $O(n)$。


## 堆
- 创建一个大顶堆，将所有数组中的元素加入堆中，并保持堆的大小小于等于 $k$。这样，堆中就保留了前 $k$ 个最大的元素。这样，堆顶的元素就是正确答案。  
`PriorityQueue` 实现原理为二叉小顶堆。

时间复杂度 $O(nlogk)$，空间复杂度 $O(k)$。

```
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>(); // 小顶堆
    for (int val : nums) {
        pq.add(val);
        if (pq.size() > k)  // 维护堆的大小为 K
            pq.poll();
    }
    return pq.peek();
}
```