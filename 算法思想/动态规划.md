**动态规划**中包含3个重要的概念： 
1. 最优子结构
2. 边界
3. 状态转移公式。以爬楼梯为例，最优子结构为 $f(10) = f(9) + f(8)$，边界是 $f(1) = 1, f(2) = 2$，状态转移公式 $f(n) = f(n-1) + f(n-2)$

---
---
# 斐波那契数列
## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
> 本质上为斐波那契数列。递归会超时（python 可设置缓存，不会超时），要用动态规划或直接应用[通项公式](https://zh.wikipedia.org/zh-cn/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97#%E8%A1%A8%E8%BE%BE%E5%BC%8F)

定义一个数组 $dp$ 存储上楼梯的方法数（为了方便讨论，数组下标从 $1$ 开始），$dp[i]$ 表示走到第 $i$ 个台阶的方法数目。  
第 $i$ 个台阶可以从第 $i - 1$ 和 $i - 2$ 个台阶再走一次到达，走到第 $i$ 个台阶的方法数为走到第 $i - 1$ 和第 $i - 2$ 个楼梯的方法数之和。

## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)
定义 $dp$ 数组用来存储最大的抢劫量，其中 $dp[i]$ 表示抢到第 $i$ 个住户时的最大抢劫量。  
由于不能抢劫邻近住户，如果抢劫了第 $i - 1$ 个住户，那么就不能再抢劫第 $i$ 个住户，所以：$dp[i] = \max (dp[i - 2]+nums[i], dp[i - 1])$  

**衍生题**：环形街区  
取 $[1, n]$ 和 $[0, n - 1]$ 两者的最大值

---
---
# 矩阵路径
## [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)
## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)
### 排列组合
> 多重集排列问题

路径方向为多重集，有 `向右` 和 `向下` 两种（方向）元素，两种元素的重数分别为 $n_{1}$ 和 $n_{2}$，有 $n = n_{1} + n_{2}$，则排列数为 $\left(\begin{array}{l}{n} \cr {n_{1}} & {n_{2}}\end{array}\right) = \frac{n!}{n_{1}!n_{2}!}$
### ⭐动态规划
令 $dp[i][j]$ 是到达 $i, j$ 的路径数，有 $dp[i][j] = dp[i-1][j] + dp[i][j-1]$

---
---
# 数组区间
## [303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/unique-paths/)
> 求数组区间 $(i, j)$ 的和

题中**强调**：会多次调用 `sumRange` 方法  
因此预先求出所有 $(0, k)$ 的和，再 `sum[j] - sum[i - 1]`

## [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)
> 等差数列满足：至少有 3 个元素、任意两个**相邻**（隔开不算）元素之差相同
 
### 暴力
每一对元素（之间至少隔着一个元素），根据两个元素之间的所有元素差值是否相等来判断是不是等差数列
### 💣动态规划（想不到这方法）
$dp[i]$ 表示**以 $A[i]$ 为结尾**（不是总的）的等差递增子区间的个数，对于 $A = [0, 1, 2, 3, 4]$，有以下结论：
```
dp[2] = 1
    [0, 1, 2]
dp[3] = dp[2] + 1 = 2
    [0, 1, 2, 3], // [0, 1, 2] 之后加一个 3
    [1, 2, 3]     // 新的递增子区间
dp[4] = dp[3] + 1 = 3
    [0, 1, 2, 3, 4], // [0, 1, 2, 3] 之后加一个 4
    [1, 2, 3, 4],    // [1, 2, 3] 之后加一个 4
    [2, 3, 4]        // 新的递增子区间
```
综上，在 `A[i] - A[i-1] == A[i-1] - A[i-2]` 时，`dp[i] = dp[i-1] + 1`  

---
---
# 分割整数
