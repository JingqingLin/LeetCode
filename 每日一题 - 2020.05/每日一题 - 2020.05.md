<center><a href="https://leetcode-cn.com/circle/article/9EZfRE/" target="_blank"><img src="https://img2020.cnblogs.com/blog/1917068/202004/1917068-20200412142133904-1149546830.png" alt="每日一题" width="70%"/></a></center>

力扣<a href="https://leetcode-cn.com/problemset/2020-05/" target="_blank">每日一题：5 月</a>（部分）。

| 一                                                                                                     | 二                                                                                                                    | 三                         | 四                         | 五                                                                                                               | 六                                                                                                                                       | 日                                                                                                         |
| ------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------- | -------------------------- | -------------------------- | ---------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| <font color=gray>27</font>                                                                             | <font color=gray>28</font>                                                                                            | <font color=gray>29</font> | <font color=gray>30</font> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank">1✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank">2✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank">3✅</a> |
| <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/jump-game-ii" target="_blank">4✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank">5✅</a> | 6                          | 7                          | 8                                                                                                                | 9                                                                                                                                        | 10                                                                                                         |
| 11                                                                                                     | 12                                                                                                                    | 13                         | 14                         | 15                                                                                                               | 16                                                                                                                                       | 17                                                                                                         |
| 18                                                                                                     | 19                                                                                                                    | 20                         | 21                         | 22                                                                                                               | 23                                                                                                                                       | 24                                                                                                         |
| 25                                                                                                     | 26                                                                                                                    | 27                         | 28                         | 29                                                                                                               | 30                                                                                                                                       | 31                                                                                                         |

## [3](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/). 无重复字符的最长子串
### ⭐滑动窗口
例题中的 `abcabcbb`，**窗口** `abc` 满足题目要求，当再进入 `a`，窗口变成了 `abca`，这时候不满足要求，需要移动窗口。  

如何移动窗口？  

当窗口为 `abc` 时，把队列的左边的元素（即 `a`）移出，再加入后方的 `a`。记录过程中的最大长度。   
时间复杂度：$O(n)$

参考：  
https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-dong-chuang-kou-by-powcai/

## [53](https://leetcode-cn.com/problems/maximum-subarray/). 最大子序和

### 动态规划
$dp[i]$ ：表示以 $nums[i]$ 结尾的连续子数组的最大和

状态转移方程：
$dp[i]=\left\lbrace\begin{array}{ll}
{dp[i-1]+nums[i],} & {\text { if } \quad dp[i-1] \geq 0}\cr
{nums[i],} & {\text { if } \quad dp[i-1]<0}
\end{array}\right.$  

- 当 $dp[i - 1] \geq 0$，说明对结果有增益效果，则保留 $dp[i - 1]$ 并加上当前遍历数字 $nums[i]$
- 当 $dp[i - 1] < 0$  时，说明对结果无增益效果，需要舍弃，则把 $dp[i]$ 更新为当前遍历数字 $nums[i]$

### 分治法

[官方题解](https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/)

## [45](https://leetcode-cn.com/problems/jump-game-ii/). 跳跃游戏 II

> 相关问题：[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

### BFS
把能跳到的位置加入队列，并维护 BFS 的层数，若最后一个点入队，返回层数

此题用 BFS 会超时，但[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)中可以通过

<img src="https://img2020.cnblogs.com/blog/1917068/202005/1917068-20200504102559376-1101082148.png" width="70%"/>

### 贪心
在[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)中，只需判断是否能够跳跃到终点，那么可以这样处理这个问题：

> 依次遍历数组中的每一个位置，并**实时**维护**最远可以到达的位置**。
>
> 对于当前遍历到的位置 $x$，如果它在**最远可以到达的位置**的范围内，那么就可以从某点通过若干次跳跃到达该位置，因此可以用 $x + nums[x]$ 更新最远可以到达的位置；如果它超出了**最远可以到达的位置**，则无法到达终点。
>
> 代码如下：
> ```Java
> public static boolean canJump(int[] nums) {
>     int n = nums.length;
>     int rightMost = 0;
>     for (int i = 0; i < n; ++i) {
>         if (i <= rightMost) {
>             rightMost = Math.max(rightMost, i + nums[i]);
>             if (rightMost >= n - 1) {
>                 return true;
>             }
>         } else {
>             break;
>         }
>     }
>     return false;
> }
> ```

而此题与上题唯一的不同之处是需要计算最短跳跃次数。那么需要维护一个数组，该数组记录了到达每个位置的最短跳跃次数。

如何更新最短跳跃次数的数组？假设当遍历到位置 `i` 时，最远距离 `rightMost` 被更新，那么，更新该数组 `[i + 1, rightMost]` 区间内的值，若 `cnt[i] + 1` 大于原数组的值，则不更新，见代码

```Java
public int jump(int[] nums) {
    int n = nums.length;
    int rightMost = 0;
    int[] cnt = new int[n];
    for (int i = 0; i < n; ++i) {
        if (i <= rightMost) {
            if (rightMost < i + nums[i]) {
                rightMost = i + nums[i];
                for (int j = i + 1; j <= rightMost && j < n; j++) {
                    cnt[j] = cnt[j] == 0 ? cnt[i] + 1 : Math.min(cnt[i] + 1, cnt[j]);
                }
            }
            if (rightMost >= n - 1) {
                return cnt[n - 1];
            }
        } else {
            break;
        }
    }
    return 0;
}
```

## [98](https://leetcode-cn.com/problems/validate-binary-search-tree/). 验证二叉搜索树

有两种思路：
1. 根据二叉搜索树中序遍历为升序的特性来判断
2. 递归

中序遍历思路较清晰，此处对“递归法”进行解释。

对于二叉搜索树中某结点，**左子树所有节点小于它；右子树所有结点大于它**。因此递归时，设置两个参数 `upper` 和 `lower` 代表左右子树的数值区间（开区间）。

如何确定区间的值：

- 对左子树进行递归时，`lower` 不变，`upper` 变为当前结点的值
- 对右子树进行递归时，`upper` 不变，`lower` 变为当前结点的值

代码如下：

```Java
public static boolean isValidBST(TreeNode root) {
    return recursion(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

public static boolean recursion(TreeNode node, Long lower, Long upper) {
    if (node == null) {
        return true;
    }
    if (node.val <= lower || node.val >= upper) {
        return false;
    }
    if (!recursion(node.right, (long) node.val, upper) || !recursion(node.left, lower, (long) node.val)) {
        return false;
    }
    return true;
}
```

力扣的测试用例中，出现了 Integer 边界值的测试用例（若区间初值为 Integer 的边界值，则对于 `[2147483647]` 会返回 false），所以将左右区间范围改为 Long 的区间