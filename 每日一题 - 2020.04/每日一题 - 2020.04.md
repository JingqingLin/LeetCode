<center><a href="https://leetcode-cn.com/circle/article/9EZfRE/" target="_blank"><img src="https://img2020.cnblogs.com/blog/1917068/202004/1917068-20200412142133904-1149546830.png" alt="每日一题" width="70%"/></a></center>

力扣<a href="https://leetcode-cn.com/problemset/2020-04/" target="_blank">每日一题：4 月</a>（部分）。4 月的题难度等级为<font color=#ed7336>中等</font>和<font color=#ec4c47>困难</font>，会从各题解中学习一些比较好的思想，但一些费体力的题就不做记录（比如 4.12 的“交点”题）

| 一                                                                                                         | 二                                                                                                             | 三                                                                                                                                                | 四                                                                                                              | 五                                                                                                                    | 六                                                                                                             | 日                                                                                                            |
| ---------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| <font color=gray>30</font>                                                                                 | <font color=gray>31</font>                                                                                     | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings" target="_blank">1✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/game-of-life" target="_blank">2✅</a>         | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/string-to-integer-atoi" target="_blank">3✅</a>     | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/trapping-rain-water" target="_blank">4✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/lfu-cache" target="_blank">5✅</a>          |
| <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/edit-distance" target="_blank">6✅</a>   | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/rotate-matrix-lcci" target="_blank">7✅</a>  | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank">8✅</a>                     | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank">9✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/reverse-words-in-a-string" target="_blank">10✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/super-egg-drop" target="_blank">11✅</a>     | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/intersection-lcci" target="_blank">12✅</a> |
| <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/design-twitter" target="_blank">13✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/add-two-numbers-ii" target="_blank">14✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/01-matrix" target="_blank">15✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/merge-intervals" target="_blank">16✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/jump-game" target="_blank">17✅</a> | 18                                                                                                             | 19                                                                                                            |
| 20                                                                                                         | 21                                                                                                             | 22                                                                                                                                                | 23                                                                                                              | 24                                                                                                                    | 25                                                                                                             | 26                                                                                                            |
| 27                                                                                                         | 28                                                                                                             | 29                                                                                                                                                | 30                                                                                                              | <font color=gray>1</font>                                                                                             | <font color=gray>2</font>                                                                                      | <font color=gray>3</font>                                                                                     |

代码托管在 <a href="https://github.com/JingqingLin/LeetCode/tree/master/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%20-%202020.04" target="_blank">GitHub</a>

## [1111](https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/). 有效括号的嵌套深度

题目很啰嗦。嵌套深度就是栈的最大深度，A 和 B 要求把栈的深度尽量对等分，所以可以把栈的深度为奇数的分给 B，偶数的分给 A

```Java
Seq     =   (  (  )  (  (  )  )  (  )  )
嵌套深度 = [ 1, 2, 2, 2, 3, 3, 2, 2, 2, 1]
分组情况 = [ A, B, B, B, A, A, B, B, B, A]
最后输出 = [ 0, 1, 1, 1, 0, 0, 1, 1, 1, 0]

public static int[] maxDepthAfterSplit(String seq) {
    int[] ans = new int[seq.length()];
    int depth = 0;
    int index = 0;
    for (char c : seq.toCharArray()) {
        if (c == '(') {
            depth++;
            ans[index++] = depth % 2;
        } else {
            ans[index++] = depth % 2;
            depth--;
        }
    }
    return ans;
}
```

## [289](https://leetcode-cn.com/problems/game-of-life/). 生命游戏

如何原地解决？https://leetcode-cn.com/problems/game-of-life/solution/sheng-ming-you-xi-by-leetcode-solution/

## [42](https://leetcode-cn.com/problems/trapping-rain-water/). 接雨水

直接看[官方题解](https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/)

### ⭐ 动态编程

左右各扫描一次

<img src="https://user-gold-cdn.xitu.io/2020/4/11/171688e72b1e69a4?w=1886&h=1396&f=png&s=521073" width="70%"/>

### 双指针

### 单调栈

想不到

## ⭐ 面试题 [01.07](https://leetcode-cn.com/problems/rotate-matrix-lcci/). 旋转矩阵

### 原地旋转

https://leetcode-cn.com/problems/rotate-matrix-lcci/solution/xuan-zhuan-ju-zhen-by-leetcode-solution/

### 两次翻转

上下翻 + 对角线翻

## [151](https://leetcode-cn.com/problems/reverse-words-in-a-string/). 翻转字符串里的单词

### 使用语言特性

很多语言对字符串提供了 `split`（拆分），`reverse`（翻转）和 `join`（连接）等方法，因此我们可以简单的调用内置的 API 完成操作

```Java
public static String reverseWords(String s) {
    // 除去开头和末尾的空白字符
    s = s.trim();
    // 正则匹配连续的空白字符作为分隔符分割
    List<String> wordList = Arrays.asList(s.split("\\s+"));
    Collections.reverse(wordList);
    return String.join(" ", wordList);
}
```

- 学到一个新方法 `String.join()`：为 charSequence 加入 delimiter（分隔符）

### 双端队列

- 学到一个新方法 `StringBuilder.setLength()`

## [887](https://leetcode-cn.com/problems/super-egg-drop/). 鸡蛋掉落

### 动态规划

李永乐老师视频讲解：

<!-- B 站嵌入参数调整：https://www.xbeibeix.com/bilibili3/ -->

<!-- 保持宽高比（js）：https://blog.csdn.net/sloafer/article/details/82659360 -->

B 站：

<iframe width="100%" src="//player.bilibili.com/player.html?aid=96214853&bvid=BV1KE41137PK&cid=164251653&page=1&high_quality=1&danmaku=0" allowfullscreen scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>

油管：

<iframe width="80%" src="https://www.youtube.com/embed/mLV_vOet0ss" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

dp 思想截图：

<img src="https://img2020.cnblogs.com/blog/1917068/202004/1917068-20200413205316632-1363712422.png" width="70%"/>

按照动规思想写出代码，

```Java
public static int superEggDrop(int K, int N) {
    // N 层 K 蛋
    int[][] dp = new int[K + 1][N + 1];
    for (int i = 1; i <= K; i++) {
        dp[i][1] = 1;
    }
    for (int j = 1; j <= N; j++) {
        dp[1][j] = j;
    }
    // 蛋先遍历
    for (int i = 2; i <= K; i++) {
        for (int j = 2; j <= N; j++) {
            int min = Integer.MAX_VALUE;
            for (int k = 1; k <= j; k++) {
                min = Math.min(min, Math.max(dp[i - 1][k - 1], dp[i][j - k]) + 1);
            }
            dp[i][j] = min;
        }
    }
    return dp[K][N];
}
```

提交后超时。从转移方程入手，我们可以发现 `Math.max(dp[i - 1][k - 1], dp[i][j - k]) + 1` 中，

- 当 `k` 增大时，`dp[i - 1][k - 1]` 是递增的，因为层数 `k` 越多，需要的次数就越多
- 当 `k` 增大时，`dp[i][j - k]` 是递减的，因为层数 `j - k` 越小，需要的次数就越少

类似于下图：

<img src="https://img2020.cnblogs.com/blog/1917068/202004/1917068-20200413205206516-1038290242.png" width="70%"/>

因此 max 在两者相交时取到最小值。那么我们令 `low = 1, high = j`（当前总楼层数），`index = (low + high) / 2`

```Java
public static int superEggDrop(int K, int N) {
    ...
    // 蛋先遍历 + 二分查找
    for (int i = 2; i <= K; i++) {
        for (int j = 2; j <= N; j++) {
            int low = 2, high = j;
            while (low < high) {
                int m = low + (high - low) / 2;
                // y1 递增，y2 递减
                int y1 = dp[i - 1][m - 1], y2 = dp[i][j - m];
                if (y1 > y2) {
                    high = m - 1;
                } else if (y1 < y2) {
                    low = m + 1;
                } else {
                    low = high = m;
                }
            }
            // low 和 high 有可能是不相等的 low - 1 = high，因为他们的交点不在整数层上
            if (low == high) {
                dp[i][j] = Math.max(dp[i - 1][low - 1], dp[i][j - low]) + 1;
            } else {
                dp[i][j] = Math.min(Math.max(dp[i - 1][low - 1], dp[i][j - low]), Math.max(dp[i - 1][high - 1], dp[i][j - high])) + 1;
            }
        }
    }
    return dp[K][N];
}
```

### 决策单调性、数学法

[官方题解](https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution/)

## [355](https://leetcode-cn.com/problems/design-twitter/). 设计推特

关键在于 `getNewsFeed(userId)`（获取最近十条推文流）如何设计，有两种思路：

1. 将所有推文存储到链表（准确地说用链表 + 哈希表。链表用来保持时间顺序；哈希表用于对推文和用户做映射关系），获得推流时，判断推文是否满足要求
2. 将推文根据用户 ID 分开存储，每个用户的推文用链表 + 哈希表存储。那么问题其实就等价于有若干个有序的链表，我们需要找到它们合起来最近的十条推文，问题就转化为 ⭐[合并 K 个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

## [445](https://leetcode-cn.com/problems/add-two-numbers-ii/). 两数相加 II

题目建议不修改（反转）链表，所以通过**栈**暂存链表以达到反转效果

## [542](https://leetcode-cn.com/problems/01-matrix/). 01 矩阵
### ⭐BFS
遍历矩阵，若为 0 ，则把 0 加入队列并开始 BFS，设置一个 distance 变量记录 BFS 层数，遇到 1 则更新层数。对于矩阵中的每个 0，都要从它开始做 BFS，但这样的时间复杂度非常高，如下地图


0 <font color=red>0</font> 0  
0 1 0  
<font color=green>0</font> <font color=blue>1</font> 1  

若先从红色的 0 点开始 BFS，那么蓝色的 1 会被更新成 2；再从绿色的 0 点开始 BFS，蓝色的 1 会被重新更新为 1。所以从每个 0 点更新距离的方法可能会对某个点进行多次更新（要取最小值），导致时间复杂度非常高

代码<a href="https://paste.ubuntu.com/p/GTYDkdBFPr/" target="_blank">在这</a>

解决的方法是一次性把所有的 0 都加入队列，成为 BFS 的第一层。那么经过一次 BFS，所有距离为 1 的点都会入队；第二次 BFS，所有距离为 2 的点都会入队...

本题和三月份做过的两题“[1162](https://leetcode-cn.com/problems/as-far-from-land-as-possible/). 地图分析（2020.03.29）”和“[994](https://leetcode-cn.com/problems/rotting-oranges/). 腐烂的橘子（2020.03.04）”本质上相同


代码<a href="https://paste.ubuntu.com/p/5xP2YXwnzY/" target="_blank">在这</a>

### 动态规划
[官方题解](https://leetcode-cn.com/problems/01-matrix/solution/01ju-zhen-by-leetcode-solution/)

## [56](https://leetcode-cn.com/problems/merge-intervals/). 合并区间
<img src="https://img2020.cnblogs.com/blog/1917068/202004/1917068-20200416122039044-909212316.png" width="70%"/>

按左端点排序，遍历区间，将合并后的区间放到“合并数组”中：
- 若“合并数组”为空，则把当前区间（排序后的第一个区间）加入“合并数组”
- **若当前区间的左端点小于等于“合并数组”最后一个区间的右端点**，说明有重合，只需更新“合并数组”的右区间
- 若若当前区间的左端点大于“合并数组”最后一个区间的右端点，则把当前区间加入“合并数组”

```Java
public static int[][] merge(int[][] intervals) {
    int[][] mergedArray = new int[intervals.length][];
    Arrays.sort(intervals, (o1, o2) -> o1[0] - o2[0]);
    int index = -1;
    for (int i = 0; i < intervals.length; i++) {
        int leftEnd = intervals[i][0], rightEnd = intervals[i][1];
        if (index == -1 || mergedArray[index][1] < leftEnd) {
            mergedArray[++index] = intervals[i];
        } else if (mergedArray[index][1] >= leftEnd) {
            mergedArray[index][1] = Math.max(rightEnd, mergedArray[index][1]);
        }
    }
    return Arrays.copyOf(mergedArray, index + 1);
}
```

## [55](https://leetcode-cn.com/problems/jump-game/). 跳跃游戏
### BFS
把能跳到的位置加入队列，若最后一个点入队，返回 true

### 贪心思想
明天看题解