## [1111](https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/). 有效括号的嵌套深度
题目很啰嗦（浪费时间）。嵌套深度就是栈的最大深度，A 和 B 要求把栈的深度尽量对等分，所以可以把栈的深度为奇数的分给 B，偶数的分给 A

```Java
Seq     =   (  (  )  (  (  )  )  (  )  )
嵌套深度 = [ 1, 2, 2, 2, 3, 3, 2, 2, 2, 1]
分组情况 = [ A, B, B, B, A, A, B, B, B, A]
最后输出 = [ 0, 1, 1, 1, 0, 0, 1, 1, 1, 0]

public static int[] maxDepthAfterSplit(String seq) {
    int[] ans = new int[seq.length()];
    int depth = 0;
    int index = 0;
    for (char c : seq.toCharArray()) {
        if (c == '(') {
            depth++;
            ans[index++] = depth % 2;
        } else {
            ans[index++] = depth % 2;
            depth--;
        }
    }
    return ans;
}
```


## [42](https://leetcode-cn.com/problems/trapping-rain-water/). 接雨水
直接看[官方题解](https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/)

### ⭐动态编程
左右各扫描一次

<img src="https://user-gold-cdn.xitu.io/2020/4/11/171688e72b1e69a4?w=1886&h=1396&f=png&s=521073" width="70%"/>


### 双指针

### 单调栈
想不到

## ⭐面试题 [01.07](https://leetcode-cn.com/problems/rotate-matrix-lcci/). 旋转矩阵
### 原地旋转
https://leetcode-cn.com/problems/rotate-matrix-lcci/solution/xuan-zhuan-ju-zhen-by-leetcode-solution/

### 两次翻转
上下翻 + 对角线翻

## [151](https://leetcode-cn.com/problems/reverse-words-in-a-string/). 翻转字符串里的单词
### 使用语言特性
很多语言对字符串提供了 `split`（拆分），`reverse`（翻转）和 `join`（连接）等方法，因此我们可以简单的调用内置的 API 完成操作

```Java
public static String reverseWords(String s) {
    // 除去开头和末尾的空白字符
    s = s.trim();
    // 正则匹配连续的空白字符作为分隔符分割
    List<String> wordList = Arrays.asList(s.split("\\s+"));
    Collections.reverse(wordList);
    return String.join(" ", wordList);
}
```

- 学到一个新方法 `String.join()`：为 charSequence 加入 delimiter（分隔符）

### 双端队列
- 学到一个新方法 `StringBuilder.setLength()`

## [887](https://leetcode-cn.com/problems/super-egg-drop/). 鸡蛋掉落

### 动态规划
李永乐老师视频讲解：


<!-- B 站嵌入参数调整：https://www.xbeibeix.com/bilibili3/ -->

<!-- 保持宽高比（js）：https://blog.csdn.net/sloafer/article/details/82659360 -->

B 站：

<iframe width="100%" src="//player.bilibili.com/player.html?aid=96214853&bvid=BV1KE41137PK&cid=164251653&page=1&high_quality=1&danmaku=0" allowfullscreen scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>

油管：

<iframe width="80%" src="https://www.youtube.com/embed/mLV_vOet0ss" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

dp 思想截图：

<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/20200411161911.png" width="70%"/>

按照动规思想写出代码，

```Java
public static int superEggDrop(int K, int N) {
    // N 层 K 蛋
    int[][] dp = new int[K + 1][N + 1];
    for (int i = 1; i <= K; i++) {
        dp[i][1] = 1;
    }
    for (int j = 1; j <= N; j++) {
        dp[1][j] = j;
    }
    // 蛋先遍历
    for (int i = 2; i <= K; i++) {
        for (int j = 2; j <= N; j++) {
            int min = Integer.MAX_VALUE;
            for (int k = 1; k <= j; k++) {
                min = Math.min(min, Math.max(dp[i - 1][k - 1], dp[i][j - k]) + 1);
            }
            dp[i][j] = min;
        }
    }
    return dp[K][N];
}
```
提交后超时。从转移方程入手，我们可以发现 `Math.max(dp[i - 1][k - 1], dp[i][j - k]) + 1` 中，

- 当 `k` 增大时，`dp[i - 1][k - 1]` 是递增的，因为层数 `k` 越多，需要的次数就越多
- 当 `k` 增大时，`dp[i][j - k]` 是递减的，因为层数 `j - k` 越小，需要的次数就越少

类似于下图：

<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/20200411163351.png" width="70%"/>

因此 max 在两者相交时取到最小值。那么我们令 `low = 1, high = j`（当前总楼层数），`index = (low + high) / 2`

```Java
public static int superEggDrop(int K, int N) {
    ...
    // 蛋先遍历 + 二分查找
    for (int i = 2; i <= K; i++) {
        for (int j = 2; j <= N; j++) {
            int low = 2, high = j;
            while (low < high) {
                int m = low + (high - low) / 2;
                // y1 递增，y2 递减
                int y1 = dp[i - 1][m - 1], y2 = dp[i][j - m];
                if (y1 > y2) {
                    high = m - 1;
                } else if (y1 < y2) {
                    low = m + 1;
                } else {
                    low = high = m;
                }
            }
            // low 和 high 有可能是不相等的 low - 1 = high，因为他们的交点不在整数层上
            if (low == high) {
                dp[i][j] = Math.max(dp[i - 1][low - 1], dp[i][j - low]) + 1;
            } else {
                dp[i][j] = Math.min(Math.max(dp[i - 1][low - 1], dp[i][j - low]), Math.max(dp[i - 1][high - 1], dp[i][j - high])) + 1;
            }
        }
    }
    return dp[K][N];
}
```

### 决策单调性、数学法
[官方题解](https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution/)
