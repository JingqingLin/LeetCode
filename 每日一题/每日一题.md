## [1103](https://leetcode-cn.com/problems/distribute-candies-to-people/). 分糖果 II

等差数列求和：https://leetcode-cn.com/problems/distribute-candies-to-people/solution/fen-tang-guo-ii-by-leetcode-solution/

主要是如何求 `p`

## [169](https://leetcode-cn.com/problems/majority-element/). 多数元素
> 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 `⌊ n/2 ⌋` 的元素

排序数组，`nums[nums.length / 2]` 肯定是多数元素

## [945](https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/). 使数组唯一的最小增量
### 计数法、排序法
https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/shi-shu-zu-wei-yi-de-zui-xiao-zeng-liang-by-leet-2/

### 线性探测法
https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/solution/ji-shu-onxian-xing-tan-ce-fa-onpai-xu-onlogn-yi-ya/

#### 路径压缩（并查集知识，详见算法笔记）
问题的由来：  
<img src="https://cdn.jsdelivr.net/gh/JingqingLin/ImageHosting@master/img/20200324005441.png" width="70%"/>

本题中的情况：若出现 5 个 n，那么每次都是从第 n 位开始往后探测，显然会很耗时。所以每次放置好一个 n 后，把 `pos[n]` 修改为新的位置。比如第 4 个 n 放在 n + 3 的位置，那么放置好之后就把 `pos[n] = n + 3`，那么下次探测就从 `n + 3` 开始

## ⭐[820](https://leetcode-cn.com/problems/short-encoding-of-words/). 单词的压缩编码
### 根据长度排序（慢）
根据字符串长度降序排序：`{"atime", "aatime", "btime"}` -> `{aatime, atime, btime}`

若字符串不包含于索引串，就把字符串加入索引串。由于存在 `well` 和 `we` 这种情况，所以不能单纯地 `contains`。利用 `#` 这个特点，比较 `well#` 和 `we#` 的包含关系

### 倒序并排序
倒序并排序字符串：`{"atime", "aatime", "btime"}` -> `{"emita", "emitaa", "emitb"}`，String 没有 `reverse` 方法，要手动转一下

比较相邻字符串是否有包含关系即可，包含即不加入索引串，不包含即加入前一个字符串（只需记录索引串的长度）

```Java
// 比较相邻字符串，若后者包含前者则跳过
for (int i = 0; i < wordsLen - 1; i++) {
    int len = reverseWords[i].length();
    if (reverseWords[i + 1].startsWith(reverseWords[i])) {
        continue;
    }
    indexLen += len + 1;
}
```

**学到一个新方法**：`String.StartsWith()`，检测字符串是否以指定的前缀开始

```Java
public boolean startsWith(String prefix, int toffset)
或
public boolean startsWith(String prefix)
```

### 存储后缀（很难想到）
首先将所有单词加入哈希表

题目限制了单词长度不大于 7，枚举所有单词的后缀，若后缀存在于哈希表，则删除这个后缀。比如哈希表里有 `time` 和 `me`，遍历 `time` 的后缀，遍历到 `me` 时，哈希表中存在这个后缀，则删除 `me` 这个后缀

```Java
public static int minimumLengthEncoding(String[]words) {
    Set<String> good = new HashSet(Arrays.asList(words));
    for (String word : words) {
        for (int k = 1; k < word.length(); ++k)
            good.remove(word.substring(k));
    }
    int ans = 0;
    for (String word : good)
        ans += word.length() + 1;
    return ans;
}
```

### ⭐[字典树](https://zh.wikipedia.org/wiki/Trie)（前缀树）
> 字典树可用于搜索提示或词频统计

<img src="https://i.loli.net/2020/03/28/pNs12f8hrcJ3aUV.png" width="70%">

字典树的叶子节点路径长度和即为答案

字典树的构造见代码：https://github.com/JingqingLin/LeetCode/blob/master/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/820.%20%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/src/PrefixTree.java
